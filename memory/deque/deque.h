#pragma once#include <initializer_list>#include <algorithm>class CircullarBuffer {public:    CircullarBuffer() = default;    CircullarBuffer(CircullarBuffer&& rhs) {        delete[] data_;        data_ = rhs.data_;        rhs.data_ = nullptr;        head_ = rhs.head_;        rhs.head_ = 0;        size_ = rhs.size_;        rhs.size_ = 0;        capacity_ = rhs.capacity_;        rhs.capacity_ = 0;    }    const int* operator[](size_t idx) const {        return At(idx);    }    int* operator[](size_t idx) {        return At(idx);    }    int* Front() {        return At(0);    }    int* Back() {        return At(size_ - 1);    }    void PushBack(int* value) {        PushAtIndex(size_, value);    }    void PushFront(int* value) {        PushAtIndex(-1, value);        head_ = Advance(head_, -1);    }    void PopBack() {        --size_;    }    void PopFront() {        head_ = Advance(head_, 1);        --size_;    }    size_t Size() const {        return size_;    }    void Clear() {        delete[] data_;        data_ = nullptr;        head_ = 0;        size_ = 0;        capacity_ = 0;    }    void Swap(CircullarBuffer& rhs) {        std::swap(data_, rhs.data_);        std::swap(head_, rhs.head_);        std::swap(size_, rhs.size_);        std::swap(capacity_, rhs.capacity_);    }    ~CircullarBuffer() {        delete[] data_;    }private:    int** data_ = nullptr;  // unique_ptr?    size_t head_ = 0;    size_t size_ = 0;    size_t capacity_ = 0;    int Advance(size_t start, int64_t steps) const {        return (start + steps) % capacity_;    }    int* At(size_t idx) const {        int elem_idx = Advance(head_, idx);        if (data_ == nullptr) {            return nullptr;        }        return data_[elem_idx];    }    void Reallocate() {        size_t new_capacity = std::max(capacity_ * 2, static_cast<size_t>(1uz));        int** new_data = new int*[new_capacity];        for (size_t i = 0; i < size_; ++i) {            new_data[i] = At(i);        }        data_ = data_ ? data_ : new int*[capacity_ = 1];        head_ = 0;        capacity_ = new_capacity;        delete[] data_;        data_ = new_data;    }    void PushAtIndex(int64_t idx, int* value) {        if (size_ == capacity_) {            Reallocate();        }        size_t new_idx = Advance(head_, idx);        data_[new_idx] = value;        ++size_;    }};class Deque {public:    Deque() = default;    Deque(const Deque& rhs) : start_idx_(rhs.start_idx_), end_idx_(rhs.end_idx_), size_(rhs.size_) {        if (this == &rhs) {            return;        }        ClearBuffer();        for (size_t i = 0; i < rhs.buffer_.Size(); ++i) {            int* sub_buffer_copy = AllocateSubBuffer();            std::copy(rhs.buffer_[i], rhs.buffer_[i] + kSubBufferLen, sub_buffer_copy);            buffer_.PushBack(sub_buffer_copy);        }    }    Deque(Deque&& rhs) = default;    explicit Deque(size_t size) {        for (size_t i = 0; i < size; ++i) {            PushBack(0);        }    }    Deque(std::initializer_list<int> list) {        for (const auto& value : list) {            PushBack(value);        }    }    Deque& operator=(Deque rhs) {        Swap(rhs);        return *this;    }    void Swap(Deque& rhs) {        buffer_.Swap(rhs.buffer_);        std::swap(start_idx_, rhs.start_idx_);        std::swap(end_idx_, rhs.end_idx_);        std::swap(size_, rhs.size_);    }    void PushBack(int value) {        if (Size() == 0 || end_idx_ == 0) {            int* new_sub_buffer = AllocateSubBuffer();            buffer_.PushBack(new_sub_buffer);        }        buffer_.Back()[end_idx_] = value;        end_idx_ = Advance(end_idx_, 1);        ++size_;    }    void PopBack() {        end_idx_ = Advance(end_idx_, -1);        --size_;        if (Size() == 0 || end_idx_ == 0) {            BufferPopBack();        }    }    void PushFront(int value) {        if (Size() == 0 || start_idx_ == 0) {            int* new_sub_buffer = AllocateSubBuffer();            buffer_.PushFront(new_sub_buffer);        }        start_idx_ = Advance(start_idx_, -1);        buffer_.Front()[start_idx_] = value;        ++size_;    }    void PopFront() {        start_idx_ = Advance(start_idx_, 1);        --size_;        if (Size() == 0 || start_idx_ == 0) {            BufferPopFront();        }    }    int& operator[](size_t ind) {        const auto& [sub_buffer_index, value_index] = CalculateCoordinates(ind);        return buffer_[sub_buffer_index][value_index];    }    int operator[](size_t ind) const {        const auto& [sub_buffer_index, value_index] = CalculateCoordinates(ind);        if (buffer_[sub_buffer_index] == nullptr) {            return 0;        }        return buffer_[sub_buffer_index][value_index];    }    size_t Size() const {        return size_;    }    void Clear() {        ClearBuffer();        start_idx_ = 0;        end_idx_ = 0;        size_ = 0;    }    ~Deque() {        Clear();    }private:    CircullarBuffer buffer_;    size_t start_idx_ = 0;    size_t end_idx_ = 0;    size_t size_ = 0;    constexpr static size_t kSubBufferSize = 512;    constexpr static size_t kSubBufferLen = kSubBufferSize / sizeof(int);    int* AllocateSubBuffer() {        return new int[kSubBufferLen];    }    size_t Advance(size_t start, int64_t step) {        return (start + step) % kSubBufferLen;    }    std::pair<int, int> CalculateCoordinates(int idx) const {        int new_index = start_idx_ + idx;        int sub_buffer_index = new_index / kSubBufferLen;        int value_index = new_index % kSubBufferLen;        return {sub_buffer_index, value_index};    }    void ClearBuffer() {        while (buffer_.Size() > 0) {            BufferPopFront();        }    }    void BufferPopFront() {        delete[] buffer_.Front();        buffer_.PopFront();    }    void BufferPopBack() {        delete[] buffer_.Back();        buffer_.PopBack();    }};